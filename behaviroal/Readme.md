# 行为型模式

```text
在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：

```
常见的设计模式分为以下类别(共11个)：
```text
- 观察者模式（Observer）  #典型的发布订阅
- 状态模式（State）
- 策略模式（Strategy）
- 职责链模式（Chain of Responsibility）
- 命令模式（Command） 
- 访问者模式（Visitor）  
- 调停者模式（Mediator）
- 备忘录模式（Memento） #如：虚拟机快照  #没讲（克隆：深copy、快照：浅copy）
- 迭代器模式（Iterator）   
- 解释器模式（Interpreter） 
- 模板方法（Template Method）
```

## 职责链模式(Chain of Responsibility)
```text
职责链模式（Chain of Responsibility）是一种行为型设计模式，它通过将请求的发送者和接收者解耦，从而使多个对象都有机会处理这个请求。
```
实现思路：

在职责链模式中，我们定义一系列的处理器对象，每个处理器对象都包含一个对下一个处理器对象的引用。

当请求从客户端发送到处理器对象时，第一个处理器对象会尝试处理请求，如果它不能处理请求，则将请求传递给下一个处理器对象，以此类推，直到请求被处理或者所有的处理器对象都不能处理请求。

职责链模式通常涉及以下角色：
- 处理器接口（Handler Interface）：定义处理器对象的接口，包含处理请求的方法和对下一个处理器对象的引用。
- 具体处理器类（Concrete Handlers）：实现处理器接口，处理请求或将请求传递给下一个处理器对象。
- 客户端（Client）：创建处理器对象的链，将请求发送给链的第一个处理器对象。

总的来说，职责链模式可以使多个对象都有机会处理请求，并且可以灵活地配置处理器对象的顺序和组合，从而提高系统的灵活性和可扩展性。

## 命令模式（Command）
```text
命令模式（Command）是一种行为型设计模式，它将请求封装成一个对象，从而使您可以将不同的请求与其请求的接收者分开。这种模式的目的是通过将请求发送者和请求接收者解耦来实现请求的发送、执行和撤销等操作。
```
实现思路：
- 在命令模式中，我们定义一个 Command 接口，该接口包含一个 execute 方法，用于执行命令。
- 我们还定义了一个 Invoker 类，它用于发送命令，可以接受一个 Command 对象，并在需要时调用该对象的 execute 方法。
- 我们还定义了一个 Receiver 类，它实际执行命令，包含一些特定于应用程序的业务逻辑。

命令模式涉及以下角色：
- Command 接口：定义了一个执行命令的方法 execute。
- 具体命令类（Concrete Command）：实现了 Command 接口，实现 execute 方法，包含一个接收者对象，执行具体的业务逻辑。
- Invoker 类：负责发送命令，它包含一个 Command 对象，可以在需要时调用该对象的 execute 方法。
- Receiver 类：包含一些特定于应用程序的业务逻辑，实际执行命令。

## 解释器模式（Interpreter Pattern）
```text
解释器模式（Interpreter Pattern）是一种行为型设计模式，它定义了一种语言文法，以及一个解释器，用于解释该语言中的句子。解释器模式通常用于解决特定类型的问题，例如解释计算器表达式，SQL 查询语句等。
```
解释器模式包括三个核心角色：
- Context（上下文）：它是解释器的运行环境。它存储解释器所需的一些全局信息。
- Abstract Expression（抽象表达式）：它是定义所有表达式的接口，通常包含解释方法 interpret()。
- Concrete Expression（具体表达式）：它实现抽象表达式接口，用于解释特定类型的表达式。


## 迭代器模式（Iterator）
```text
迭代器模式（Iterator）是一种行为型设计模式，它允许你在不暴露集合底层实现的情况下遍历集合中的所有元素。
```
实现思路：
- 在迭代器模式中，集合类（如列表、树等）将遍历操作委托给一个迭代器对象，而不是直接实现遍历操作。
- 迭代器对象负责实现遍历操作，以及保存当前遍历位置等状态。
- 这样，集合类就可以将遍历操作与集合底层实现解耦，从而使得集合类更加简单、灵活和易于维护。

- 迭代器模式通常由以下几个角色组成：
- 迭代器（Iterator）：定义了迭代器的接口，包含用于遍历集合元素的方法，如 next()、has_next() 等。
- 具体迭代器（ConcreteIterator）：实现了迭代器接口，负责实现迭代器的具体遍历逻辑，以及保存当前遍历位置等状态。
- 集合（Aggregate）：定义了集合的接口，包含用于获取迭代器对象的方法，如 create_iterator() 等。
- 具体集合（ConcreteAggregate）：实现了集合接口，负责创建具体迭代器对象，以便遍历集合中的元素。


## 中介者模式（Mediator）
```text
中介者模式（Mediator）是一种行为型设计模式，它用于将多个对象之间的交互解耦，从而使得对象之间的通信更加简单和灵活。
```

实现思路：
- 在中介者模式中，多个对象之间不直接相互通信，而是通过一个中介者对象进行通信。
- 这样，每个对象只需要和中介者对象通信，而不需要知道其他对象的存在。
- 中介者对象负责协调各个对象之间的交互，使得系统更加灵活和易于维护。

中介者模式通常由以下几个角色组成：
- 抽象中介者（Mediator）：定义了各个同事对象之间交互的接口，它通常包含一个或多个抽象方法，用于定义各种交互操作。
- 具体中介者（ConcreteMediator）：实现了抽象中介者接口，负责协调各个同事对象之间的交互关系。
- 抽象同事类（Colleague）：定义了各个同事对象的接口，包含一个指向中介者对象的引用，以便与中介者进行通信。
- 具体同事类（ConcreteColleague）：实现了抽象同事类的接口，负责实现各自的行为，并且需要和中介者对象进行通信。

## 备忘录模式（Memento）
```text
备忘录模式（Memento）是一种行为型设计模式，它允许在不暴露对象实现细节的情况下保存和恢复对象的内部状态。备忘录模式的核心是备忘录类，它用于存储对象的状态信息，同时提供给其他类访问状态信息的接口。
```
备忘录模式包括三个核心角色：
- Originator（发起人）：它是需要保存状态的对象。它创建备忘录对象来存储内部状态，并可以使用备忘录对象来恢复其先前的状态。
- Memento（备忘录）：它是存储发起人对象内部状态的对象。备忘录对象由发起人创建，并由发起人决定何时读取备忘录以恢复其先前的状态。
- Caretaker（管理者）：它负责备忘录的安全保管。它只能将备忘录传递给其他对象，不能修改备忘录的内容。
在 Python 中，备忘录模式通常使用 Python 的内置 copy 模块和 dict 属性来实现。下面是一个简单的备忘录模式的 Python 实现：


## 观察者模式(Observer)
```text
观察者模式（Observer）是一种软件设计模式，它定义了对象之间的一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。这个模式也被称为发布/订阅模式（Publish/Subscribe），事件模型（Event Model）或消息机制（Message Pattern）。
```

实现思路：
- 在观察者模式中，有两种类型的对象：观察者和主题（Subject）。
- 主题是被观察的对象，它维护了一个观察者列表，用于记录所有依赖于它的观察者。
- 当主题状态发生变化时，它会自动通知所有观察者，让它们能够及时更新自己的状态。
- 观察者是依赖于主题的对象，当主题状态发生变化时，它们会收到通知并根据新状态更新自己的状态。


## 状态模式（State）
```text
状态模式（State）是一种行为型设计模式，它允许对象在不同的内部状态下改变其行为。在状态模式中，一个对象可以有多个状态，每个状态都对应着一组不同的行为。对象根据自身的状态，选择不同的行为。这种模式将状态抽象成独立的类，使得状态之间可以相互切换，而不影响对象的整体行为。
```
状态模式由三个核心组件构成：
- 环境（Context）：表示当前对象的状态，它维护一个对抽象状态类的引用，以便能够切换状态。
- 抽象状态（State）：定义一个接口，用于封装与环境相关的行为。
- 具体状态（ConcreteState）：实现抽象状态接口，实现与环境相关的行为。
- 在状态模式中，当对象的状态发生变化时，它会将状态的处理委托给当前状态对象。状态对象会负责处理相关的操作，并且在必要时会将环境的状态切换到新的状态。

## 策略模式（Strategy）
```text
策略模式（Strategy）是一种行为型设计模式，它允许在运行时选择算法的不同实现方式。该模式的基本思想是将算法封装在可互换的策略对象中，使得客户端能够动态地选择算法的实现方式。
```
实现思路：
- 在策略模式中，通常有一个上下文对象（Context），它持有一个或多个策略对象（Strategy），并将具体的任务委托给其中的某个策略对象来完成。
- 策略对象之间通常是相互独立的，它们之间没有共享状态，客户端可以自由地选择不同的策略对象。

优缺点：
- 策略模式的优点是可以提高代码的可维护性和可扩展性，因为它将算法的实现与上下文对象分离，使得修改或增加新的算法实现变得更加容易。
- 缺点是可能会增加类的数量，同时需要客户端显式地选择不同的策略对象，这可能会使代码变得更加复杂。

## 模板方法模式（TemplateMethod）
```text
模板方法模式（Template Method）是一种行为设计模式，它定义了一个算法的骨架，而将某些步骤的实现延迟到子类中。该模式主要用于在不改变算法结构的情况下重定义算法的某些步骤，以适应不同的需求。
```

模板方法模式的实现需要抽象类和具体子类的参与，一般包括以下几个步骤：
- 定义抽象类：定义一个抽象类作为算法的骨架，该抽象类中包含了算法的核心部分以及一些抽象方法，抽象方法表示算法中需要子类实现的具体步骤。
- 实现具体子类：根据抽象类定义具体的子类，子类中实现了抽象方法，以完成算法的具体步骤。子类也可以实现一些钩子方法（Hook Method）以影响算法的执行。
- 定义具体方法：抽象类中还可以包含一些具体方法，这些具体方法可以提供算法的默认实现，但也可以被具体子类覆盖。

## 访问者模式（Visitor）
```text
访问者模式（Visitor）是一种行为型设计模式，它可以将算法与其所作用的对象分离开来。这种模式允许你在不改变现有对象结构的情况下向对象结构中添加新的行为。
```

实现思路：
- 访问者模式的核心思想是：将算法封装到访问者对象中，然后将访问者对象传递给对象结构中的元素，以便这些元素可以调用访问者对象中的算法。
- 访问者对象可以通过访问元素中的数据和操作来实现算法，从而避免了对元素结构的直接访问。

访问者模式通常由以下几个角色组成：
- 访问者（Visitor）：定义了用于访问元素的方法，这些方法通常以不同的重载形式出现，以便针对不同类型的元素采取不同的行为。
- 具体访问者（ConcreteVisitor）：实现了访问者接口，提供了算法的具体实现。
- 元素（Element）：定义了用于接受访问者的方法，这些方法通常以 accept() 的形式出现，以便元素可以将自己作为参数传递给访问者对象。
- 具体元素（ConcreteElement）：实现了元素接口，提供了具体的数据和操作，同时也提供了接受访问者的方法。
- 对象结构（Object Structure）：定义了元素的集合，可以提供一些方法以便访问者能够遍历整个集合。





