# 结构型模式

```text
在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低
```
常见的设计模式分为以下类别(共7个)：
```text
- 适配器模式（Adapter）
- 代理模式（Proxy）
- 装饰模式（Decorator） 
- 桥模式（Bridge、多维度）
- 组合模式（Composite）   
- 外观模式
- 享元模式（Flyweight）
```


## 适配器模式（Adapter）
```text
适配器模式（Adapter）是一种结构型设计模式，用于将一个类的接口转换为另一个类的接口。适配器模式的作用是解决两个不兼容的接口之间的兼容问题，从而使它们能够协同工作。
```

适配器模式由三个主要组件组成：
- 目标接口（Target Interface）：是客户端代码期望的接口。在适配器模式中，它通常由抽象类或接口表示。
- 适配器（Adapter）：是实现目标接口的对象。适配器通过包装一个需要适配的对象，并实现目标接口来实现适配的效果。
- 源接口（Adaptee Interface）：是需要被适配的接口。在适配器模式中，它通常由一个或多个具体类或接口表示。

适配器模式通常有两种实现方式：
- 类适配器模式：通过继承来实现适配器，从而使适配器成为源接口的子类，并实现目标接口。这种方式需要适配器能够覆盖源接口的所有方法。
- 对象适配器模式：通过组合来实现适配器，从而使适配器持有一个源接口的对象，并实现目标接口。这种方式可以在适配器中自定义需要适配的方法，而无需覆盖源接口的所有方法。

优缺点：
- 适配器模式的优点是能够解决两个不兼容接口之间的兼容问题，并且可以使代码更加灵活和可扩展。
- 它的缺点是需要额外的适配器对象，可能会导致代码的复杂性增加。在设计过程中，需要根据具体的场景和需求，选择最合适的适配器实现方式。

## 桥接模式（Bridge）
```text
桥接模式（Bridge）是一种结构型设计模式，旨在将抽象部分和具体实现部分分离，使它们可以独立地变化。

抽象部分和实现部分分别由抽象类和实现类来表示，它们之间通过一个桥梁接口来联系。
```

就拿汽车在路上行驶的来说。即有小汽车又有公共汽车，它们都不但能在市区中的公路上行驶，也能在高速公路上行驶。这你会发现，对于交通工具（汽车）有不同的类型，然而它们所行驶的环境（路）也在变化，在软件系统中就要适应两个方面的变化？怎样实现才能应对这种变化呢？


1．Bridge模式使用 **“对象间的组合关系”** 解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。

2．所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同汽车。

3．Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。

4．Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。

## 组合模式（Composite）
```text
将对象组合成树形结构来表示整体-部分关系，使得客户端可以统一地处理单个对象和组合对象。
```
- 抽象组件（Component）：定义了组合中所有对象共有的行为，并规定了管理子组件的方法。
- 叶子组件（Leaf）：表示组合中的单个对象，叶子节点没有子节点。
- 容器组件（Composite）：表示组合中的容器对象，容器节点可以包含其他容器节点和叶子节点。
- 客户端（Client）：通过抽象组件操作组合对象。

## 装饰模式（Decorator）
```text
允许你在运行时为对象动态添加功能。装饰模式是一种替代继承的方式，它通过将对象放入包装器对象中来实现这一点。这种模式是开放封闭原则的一种具体实现方式。
```
- 在装饰模式中，有一个抽象组件（Component）类，它定义了基本的操作方法。
- 有一个具体组件（ConcreteComponent）类，它实现了抽象组件类中定义的操作方法。
- 还有一个装饰器（Decorator）类，它也实现了抽象组件类中定义的操作方法，并且它包含一个指向抽象组件类的引用。
- 此外，还有一个具体装饰器（ConcreteDecorator）类，它扩展了装饰器类，以实现额外的功能。

## 外观模式（Facade）
```text
提供了一个简单的接口，隐藏了一个或多个复杂的子系统的复杂性。外观模式可以使得客户端只需要与外观对象进行交互，而不需要与子系统中的每个对象直接交互，从而降低了客户端的复杂性，提高了系统的可维护性。
```
- 外观模式的核心思想是，提供一个简单的接口，包装一个或多个复杂的子系统，隐藏其复杂性，并向客户端提供一个更简单、更易于使用的接口。
- 在外观模式中，外观对象扮演着客户端和子系统之间的协调者，它负责将客户端的请求转发给子系统中的相应对象，并将其结果返回给客户端。

## 享元模式(Flyweight)
```text
通过共享对象来尽可能减少内存使用和对象数量。在享元模式中，存在两种对象：内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态指对象的共享部分，不随环境改变而改变；外部状态指对象的非共享部分，会随环境改变而改变。
```
- 享元模式的核心思想是尽量重用已经存在的对象，减少对象的创建和销毁，从而提高性能和节省内存。
- 它通常适用于需要大量创建对象的场景，但又不能因为对象过多而导致内存不足或性能降低的情况。

## 代理模式（Proxy）
```text
允许在访问对象时添加一些额外的行为。代理类充当客户端和实际对象之间的中介。客户端通过代理来访问实际对象，代理在访问实际对象前后执行一些额外的操作，例如权限检查、缓存等。
```
代理模式包含三个角色：抽象主题（Subject）、真实主题（Real Subject）和代理主题（Proxy Subject）。其中，抽象主题定义了真实主题和代理主题的公共接口；真实主题是实际执行操作的对象；代理主题通过实现抽象主题接口，控制对真实主题的访问。

```text
  +-------------+     +-----------------+     +---------------+
  |   Subject   |<----|   RealSubject   |     |  ProxySubject |
  +-------------+     +-----------------+     +---------------+
  |   +request()|     |  +request()     |     | +request()    |
  +-------------+     +-----------------+     +---------------+
```